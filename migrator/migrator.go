package migrator

import (
	"errors"
	"fmt"
	"github.com/golang-migrate/migrate/v4"
	"github.com/rs/zerolog/log"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"time"
)

var (
	ErrDifferentPriorityLength = errors.New("priorities need to have the same length")
	ErrDifferentVersionLength  = errors.New("versions need to have the same length")
	ErrInvalidPriority         = errors.New("priority should be a number")
)

type Direction string

const (
	MigratorVersion string    = "1.0"
	DirectionUp     Direction = "up"
	DirectionDown   Direction = "down"
)

type Migrator struct {
	Migrate *migrate.Migrate
	Config  *Config
}

func (m *Migrator) GetObjectList() ([]*DbObject, error) {
	entries, err := os.ReadDir(m.Config.DbObjectPath)
	if err != nil {
		return nil, err
	}

	orderDirEntries(entries)

	dbObjects := make([]*DbObject, 0, len(entries))
	for _, entry := range entries {
		if entry.IsDir() {
			dbObject, err := parseDir(entry, m.Config)
			if err != nil {
				return nil, err
			}

			dbObjects = append(dbObjects, dbObject)
		}
	}

	return dbObjects, nil
}

func (m *Migrator) GetObjectsForStep(step int, upOrDown Direction) (result []*DbObjectVersion, err error) {
	entries, err := m.GetObjectList()
	if err != nil {
		return nil, err
	}

	//result := make([]*DbObjectVersion, 0, len(*entries))

	for _, dbObject := range entries {
		correctVersion := 0
		for _, version := range dbObject.Versions {
			if version > correctVersion && ((upOrDown == DirectionUp && step >= version) || (upOrDown == DirectionDown && step > version)) {
				correctVersion = version
			} else {
				break
			}
		}
		if correctVersion > 0 {
			result = append(result, &DbObjectVersion{
				DbObject: dbObject,
				Version:  correctVersion,
			})

		}
	}

	return
}

func (m *Migrator) CreateObjectsForStep(step int, direction Direction) error {
	fmt.Println(" - Creating DB objects for step ", step, " started")

	objectVersions, err := m.GetObjectsForStep(step, direction)
	if err != nil {
		return err
	}

	for _, ov := range objectVersions {
		//fmt.Println("Doing ", ov.DbObject.Name, " version ", ov.Version)
		path := m.GetDbObjectVersionPath(ov)
		err = m.RunFile(path)
		if err != nil {
			return fmt.Errorf("while running file %s [version %d]: %v", ov.DbObject.Name, ov.Version, err)
		}
	}

	fmt.Println(" -- Done.")
	return nil
}

func (m *Migrator) CreateObjectsFile() error {
	filename := m.Config.DbObjectPath + "/" + m.Config.CreateObjectsFilename

	version, err := m.GetHighestAvailableVersion()
	if err != nil {
		return err
	}

	data := make([]byte, 0)

	data = append(data, []byte("-- Generated by migrator v"+MigratorVersion+" at "+time.Now().String()+"\n\n")...)

	dbObjectVersions, err := m.GetObjectsForStep(version, DirectionUp)
	if err != nil {
		return err
	}

	for _, file := range dbObjectVersions {
		sqlFilePath := m.GetDbObjectVersionPath(file)
		content, err := os.ReadFile(sqlFilePath)
		if err != nil {
			return err
		}
		data = append(data, []byte("-- Source file: "+sqlFilePath+"\n\n")...)
		content = append(content, '\n', '\n')
		data = append(data, content...)
	}

	err = os.WriteFile(filename, data, 0644)
	if err != nil {
		return err
	}

	return nil
}

func (m *Migrator) DropObjects() error {
	fmt.Println(" - Dropping DB objects started")
	err := m.RunFile(m.Config.DbObjectPath + "/" + m.Config.DropObjectsFilename)
	if err != nil {
		return err
	}
	fmt.Println(" -- Done.")
	return nil
}

func (m *Migrator) RunFile(path string) error {
	sqlFileContents, err := os.ReadFile(path)
	if err != nil {
		return err
	}

	_, err = m.Config.DB.Exec(string(sqlFileContents))
	if err != nil {
		return err
	}

	return nil
}

func (m *Migrator) GetDbObjectVersionPath(dov *DbObjectVersion) string {
	folder := m.Config.DbObjectPath
	objectFolder := LPAD(dov.DbObject.Priority, m.Config.PriorityLpad) + "_" + dov.DbObject.Name
	filename := LPAD(dov.Version, m.Config.VersionLpad) + "_" + dov.DbObject.Name + ".sql"
	return folder + "/" + objectFolder + "/" + filename
}

func (m *Migrator) GetHighestAvailableVersion() (int, error) {
	entries, err := os.ReadDir(m.Config.MigrationFilesPath)
	if err != nil {
		return 0, err
	}

	highestAvailableVersion := 0

	for i := len(entries) - 1; i > 0; i-- {
		entry := entries[i]
		if !entry.IsDir() {
			if strings.HasSuffix(entry.Name(), ".up.sql") {
				versionSplit, err := strconv.Atoi(strings.Split(entry.Name(), "_")[0])
				if err != nil {
					continue
				}
				if versionSplit > highestAvailableVersion {
					highestAvailableVersion = versionSplit
				} else {
					break
				}
			}
		}
	}

	return highestAvailableVersion, nil
}

func (m *Migrator) RunAll() error {

	cv, dirty, _ := m.Migrate.Version()
	currentVersion := int(cv)
	if dirty {
		log.Fatal().Err(errors.New("starting from dirty database")).Msg("Fix errors manually")
	}

	highestVersion, err := m.GetHighestAvailableVersion()
	if err != nil {
		log.Fatal().Err(err).Msg("unable to get highest available version")
	}

	drop := true
	for currentVersion != highestVersion {
		currentVersion, err = m.RunStep(DirectionUp, drop, currentVersion+1 == highestVersion)
		if err != nil {
			log.Fatal().Err(err).Msg("step failed")
			return err
		}
		drop = false
	}

	return nil
}

func (m *Migrator) RunStep(direction Direction, drop bool, create bool) (int, error) {
	stepIncrease := 1
	if direction == DirectionDown {
		stepIncrease = -1
	}

	cv, dirty, _ := m.Migrate.Version()
	currentVersion := int(cv)
	finalVersion := currentVersion + stepIncrease
	if dirty {
		fmt.Println("Dirty")
		return currentVersion, errors.New("migration failed, database in dirty state")
	}

	// Execute script before migration
	if drop {
		err := m.DropObjects()
		if err != nil {
			return currentVersion, err
		}
	}

	// Run step
	fmt.Println("Running step ", finalVersion, currentVersion)
	err := m.Migrate.Steps(stepIncrease)
	if errors.Is(err, migrate.ErrNoChange) {
		fmt.Println("No migration to run!")
		err = m.CreateObjectsForStep(finalVersion, direction)
		if err != nil {
			return currentVersion, err
		}
		return currentVersion, nil
	} else if err != nil {
		return currentVersion, err
	}

	// Execute script after migration
	cv, dirty, _ = m.Migrate.Version()
	currentVersion = int(cv)

	if create {
		err = m.CreateObjectsForStep(finalVersion, direction)
		if err != nil {
			return currentVersion, err
		}
	}

	return currentVersion, nil
}

func parseDir(entry os.DirEntry, config *Config) (*DbObject, error) {
	splitEntry := strings.Split(entry.Name(), "_")
	if config.PriorityLpad == 0 {
		config.PriorityLpad = len(splitEntry[0])
	} else if config.PriorityLpad != len(splitEntry[0]) {
		return nil, ErrDifferentPriorityLength
	}

	priority, err := strconv.Atoi(splitEntry[0])
	if err != nil {
		return nil, ErrInvalidPriority
	}

	versions, err := parseVersionFiles(entry.Name(), config)

	return &DbObject{
		Name:     strings.Join(splitEntry[1:], "_"),
		Priority: priority,
		Versions: versions,
	}, nil
}

func parseVersionFiles(dirName string, config *Config) ([]int, error) {
	versionFilePath := filepath.Join(config.DbObjectPath, dirName)
	versionFiles, err := os.ReadDir(versionFilePath)
	if err != nil {
		return nil, err
	}

	orderDirEntries(versionFiles)

	versions := make([]int, 0, len(versionFiles))
	for _, file := range versionFiles {
		versionString := strings.Split(file.Name(), "_")[0]
		if config.VersionLpad == 0 {
			config.VersionLpad = len(versionString)
		} else if config.VersionLpad != len(versionString) {
			return nil, ErrDifferentVersionLength
		}

		version, err := strconv.Atoi(versionString)
		if err != nil {
			return nil, err
		}

		versions = append(versions, version)
	}

	return versions, nil
}

func orderDirEntries(entries []os.DirEntry) {
	sort.Slice(entries, func(i, j int) bool {
		return entries[i].Name() < entries[j].Name()
	})
}

func New(migratorConfig *Config, migrateInstance *migrate.Migrate) (*Migrator, error) {
	return &Migrator{
		Migrate: migrateInstance,
		Config:  migratorConfig,
	}, nil
}
